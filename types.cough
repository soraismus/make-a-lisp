'use strict'

associateKeysAndValues = \array ->
  result = {}
  for i in [0 ... array.length] by 2
    # `array[i]` must be either a MAL string or MAL number.
    result[array[i].value] = array[i + 1]
  result

convertToMalType = \val ->
  getTypeConstructor!! val val

createConstantFunction = \constant \_ ->
  constant

createFactory = \type \value ->
  createMalType (value, type)

createMalHash = \jsArray ->
  _createMalHash (associateKeysAndValues jsArray)

createMalType = (value, type) ->
  map = \fn ->
    _value = fn (value, type)
    [_value, _type] = _value if jsArray? _value
    createMalType (_value, _type ?? type)
  { map, type, value }

createPredicateFor = \constant \value ->
  value == constant

createTypeUtilities = \type ->
  factory = createFactory type
  predicate = \object ->
    object.type == type
  [factory, predicate]

getFALSE = () -> FALSE
getNIL   = () -> NIL
getTRUE  = () -> TRUE

getType = \object ->
  object.type

# '!!' indicates that an error variant is returned.
getTypeConstructor!! = \val ->
  switch
    when malValue? val   then identity
    when jsNumber? val   then createMalNumber
    when jsString? val   then createMalString
    when jsFunction? val then createMalFunction
    when jsArray? val    then createMalList
    when jsObject? val   then createMalHash
    when jsFalse? val    then getFALSE
    when jsNull? val     then getNIL
    when jsTrue? val     then getTRUE
    else
      throwMalConversionError ()

getValues = \args ->
  args.map \arg -> arg.value

identity = \obj ->
  obj

jsFalse? = \value ->
  value == false

jsNull? = \value ->
  value == null

jsTrue? = \value ->
  value == true

liftFunction = (_fn) ->
  fn ((args...) -> wrap (_fn ((getValues args)...)))

mal-seq? = \value ->
  mal-list? value || malVector? value

malValue? = \object ->
  !! object.type

ofJavascriptType? = \type \value ->
  typeof value == type

[
  [createMalAtom,     malAtom?    ]
  [_createMalHash,    mal-hash?    ]
  [createMalFunction, malFunction?]
  [createMal-keyword,  mal-keyword? ]
  [createMalList,     mal-list?    ]
  [createMalMacro,    malMacro?   ]
  [createMalNumber,   malNumber?  ]
  [createMalString,   mal-string?  ]
  [createMalSymbol,   mal-symbol?  ]
  [createMalVector,   malVector?  ]
] = [
  'atom'
  'hash'
  'fn'
  'keyword'
  'list'
  'macro'
  'number'
  'string'
  'symbol'
  'vector'
].map createTypeUtilities

[createMalFalse, createMalNil, createMalTrue] =
  ['false', 'nil', 'true'].map createFactory

FALSE = createMalFalse false
NIL   = createMalNil null
TRUE  = createMalTrue true

[malFalse?, malNil?, malTrue?] =
  [FALSE, NIL, TRUE].map createPredicateFor

[getFALSE, getNIL, getTRUE] =
  [FALSE, NIL, TRUE].map createConstantFunction

jsArray? = Array.isArray

[jsFunction?, jsNumber?, jsObject?, jsString?] =
  ['function', 'number', 'object', 'string'].map ofJavascriptType?

# -------------------------------------------------------------------------

MalConversionException = \message ->
  this.message = message
  if 'captureStackTrace' in Error
    Error.captureStackTrace(this, MalConversionException)
  else
    this.stack = (new Error()).stack

MalConversionException.prototype = Object.create(Error.prototype)
MalConversionException.prototype.name = 'MalConversionException'
MalConversionException.prototype.constructor = MalConversionException

throwMalConversionError = ->
  throw new MalConversionException()

# -------------------------------------------------------------------------

module.exports = {}
