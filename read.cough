'use strict'

blank?   = require './isBlank'
jsArray? = require './isJsArray'

{ createMalHash, createMalList, createMalVector } = require './types'

{ DEREF, QUASIQUOTE, QUOTE, SPLICE-UNQUOTE, UNQUOTE } =
  require './metaSymbols'

absent? = \tokenArray ->
  tokenArray.length == 0

# WET; cf. `metaReducible?`
arrayReducible? = \stack ->
  reducible? stack && penultimateIsArray? stack

available? = \str ->
  ! blank? str

comment? = \token ->
  token[0] == commentStart

end? = \token ->
  token in endTokens

getTokenManager = \token ->
  switch
    when start? token           then shiftStartToken!
    when end? token             then reduceEndToken!
    when meta? token            then shiftMetaToken!
    when metadataMarker? token  then ignore!
    else                             shiftAtom!

# no-op
ignore! = (stack, token) ->

meta? = \token ->
  token in metaTokens

metadataMarker? = \token ->
  token == metadataMarker

# WET; cf. `arrayReducible?`
metaReducible? = \stack ->
  reducible? stack && penultimateIsMeta? stack

reducible? = \stack ->
  stack.length > 1

parse = \tokens ->
  stack = []
  for token in tokens
    manage! = getTokenManager token
    manage! (stack, token)
  stack.pop ()

# WET; cf. `penultimateIsArray?`
penultimateIsArray? = penultimate array?
  jsArray? stack[stack.length - 2]

# WET; cf. `penultimateIsMeta?`
penultimateIsMeta? = penultimate meta?
  meta? stack[stack.length - 2]

read = \str ->
  parse (tokenize str)

reduceEndToken! = (stack, endToken) ->
  jsArray = stack.pop ()
  shift! (stack, (seqTypeConstructors[endToken] jsArray))

reduceMetaTokens! = \stack ->
  while metaReducible? stack
    value = stack.pop ()
    metaSymbol = stack.pop ()
    stack.push (list [metaSymbol, value])
  if arrayReducible? stack
    value = stack.pop ()
    array = stack[stack.length - 1]
    array.push value

shift! = (stack, value) ->
  lastValue = stack[stack.length - 1] 
  if jsArray? lastValue
    lastValue.push value
  else
    stack.push value
    reduceMetaTokens! stack

shiftAtom! = (stack, token) ->
  shift! (stack, (atomize token))

shiftMetaToken! = (stack, token) ->
  stack.push 

shiftStartToken! = (stack, token) ->
  stack.push []

start? = \token ->
  token in startTokens

tokenize = \str ->
  tokenRegex =
    /[\s,]*(~@|[\[\]{}()'`~^@]|"(?:\\.|[^\\"])*"|;.*|[^\s\[\]{}('"`,;)]*)/g
  tokens = []
  while available? (token = tokenRegex.exec(str)[1])
    continue if comment? token
    tokens.push token
  tokens

listStart      = '('
listEnd        = ')'
vectorStart    = '['
vectorEnd      = ']'
hashmapStart   = '{'
hashmapEnd     = '}'
commentStart   = ';'
deref          = '@'
quote          = '\'' 
quasiquote     = '`'
unquote        = '~'
spliceUnquote  = '~@'
metadataMarker = '^'

startTokens = [listStart, vectorStart, hashmapStart]
endTokens   = [listEnd, vectorEnd, hashmapEnd]
metaTokens  = [deref, quote, quasiquote, unquote, spliceUnquote]

metaSymbols =
  '@'  : DEREF
  '`'  : QUASIQUOTE
  '\'' : QUOTE
  '~@' : SPLICE-UNQUOTE
  '~'  : UNQUOTE

seqTypeConstructors =
  ')' : createMalList
  ']' : createMalVector
  '}' : createMalHash

module.exports = read
