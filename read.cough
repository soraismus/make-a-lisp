'use strict'

blank?   = require './isBlank'
jsArray? = require './isJsArray'

{
  createMalKeyword
  createMalNumber
  createMalString
  createMalSymbol
  FALSE
  NIL
  TRUE
} = require './types'

{ DEREF, QUASIQUOTE, QUOTE, SPLICE-UNQUOTE, UNQUOTE } =
  require './metaSymbols'

absent? = \tokenArray ->
  tokenArray.length == 0

# WET; cf. `metaReducible?`
arrayReducible? = \stack ->
  reducible? stack && penultimateIsArray? stack

atomize = \token ->
  switch
    when integerToken? token then createMalNumber (getIntegerValue token)
    when floatToken? token   then createMalNumber (getFloatValue token)
    when stringToken? token  then createMalString (getStringValue token)
    when keywordToken? token then createMalKeyword (getKeywordValue token)
    when nilToken? token     then NIL
    when trueToken? token    then TRUE
    when falseToken? token   then FALSE
    else                          createMalSymbol token

falseToken? = \token ->
  token == 'false'

nilToken? = \token ->
  token == 'nil'

trueToken? = \token ->
  token == 'true'

getFloatValue = \value ->
  parseFloat (value, 10)

floatToken? = \token ->
  /^-?[0-9]+.[0-9]+$/.test token

getIntegerValue = \token ->
  parseInt (token, 10)

integerToken? = \token ->
  /^-?[0-9]+$/.test token

getKeywordValue = \val ->
  val[1..]

keywordToken? = \token ->
  colon = ':'
  token[0] == colon

getStringValue = \val ->
  val.slice(1, val.length - 1)
     .replace(/\\"/g, '"')
     .replace(/\\n/g, '"')

stringToken? = \token ->
  doubleQuote = '"'
  token[0] == doubleQuote

available? = \str ->
  ! blank? str

comment? = \token ->
  token[0] == commentStart

end? = \token ->
  token in endTokens

getTokenManager = \token ->
  switch
    when start? token           then shiftStartToken!
    when end? token             then reduceEndToken!
    when meta? token            then shiftMetaToken!
    when metadataMarker? token  then ignore!
    else                             shiftAtom!

# no-op
ignore! = (stack, token) ->

meta? = \token ->
  token in metaTokens

metadataMarker? = \token ->
  token == metadataMarker

# WET; cf. `arrayReducible?`
metaReducible? = \stack ->
  reducible? stack && penultimateIsMeta? stack

reducible? = \stack ->
  stack.length > 1

parse = \tokens ->
  token = tokens[0]
  if start? token
    intermediateResult = []
    for 
  else if end? token
  else 

last = \array ->
  array[array.length - 1]

push = \array \value ->
  array.push value
  array

_p = (token, tokens, complex) ->
  if start? token
    correspondingEnd = getCorrespondingEnd token
    until (_token = tokens.pop ()) == correspondingEnd
      if start? _token
        push (last (push complex [])) (_p (_token, tokens, complex))
      else if end? _token
        array = complex.pop ()
        push (last complex) (getSeqConstructor _token array)
      else
        push (last complex) _token
    array = complex.pop ()
    getSeqConstructor _token array
  else
    token

# To copy an array `xs`: `xs.slice 0`
_parse2 = (token, remainingTokens) ->
  switch
    when start? token
      correspondingEndToken = getCorrespondingEndToken token
      container = []
      until ((_token = remainingTokens.pop ()) == correspondingEndToken
        [malValue, remainingTokens] = _parse2 (_token, remainingTokens.slice(0))
        container.push (_parse2 (_token, remainingTokens.slice 0))
    else
      [(atomize token), remainingTokens.slice(0)]

_parse = (token, remainingTokens) ->
  switch
    when start? token
      createMalContainer = getMalContainerFactory token
      correspondingEnd? = correspondingEndFor token
      container = []
      i = 0
      while remainingTokens.length > 0
        nextToken = remainingTokens[i]
        i++
        if correspondingEnd? nextToken
          return getMalContainerFactory container
        else  
          container.push (atomize nextToken)
      throw 'no corresponding end'
    when end? token
      null
    when meta? token
      null
    when metadataMarker? token
      null
    else
      atomize token

# WET; cf. `penultimateIsArray?`
penultimateIsArray? = penultimate array?
  jsArray? stack[stack.length - 2]

# WET; cf. `penultimateIsMeta?`
penultimateIsMeta? = penultimate meta?
  meta? stack[stack.length - 2]

read = \str ->
  parse (tokenize str)

reduceEndToken! = (stack, endToken) ->
  jsArray = stack.pop ()
  shift! (stack, (seqTypeConstructors[endToken] jsArray))

reduceMetaTokens! = \stack ->
  while metaReducible? stack
    value = stack.pop ()
    metaSymbol = stack.pop ()
    stack.push (list [metaSymbol, value])
  if arrayReducible? stack
    value = stack.pop ()
    array = stack[stack.length - 1]
    array.push value

shift! = (stack, value) ->
  lastValue = stack[stack.length - 1] 
  if jsArray? lastValue
    lastValue.push value
  else
    stack.push value
    reduceMetaTokens! stack

shiftAtom! = (stack, token) ->
  shift! (stack, (atomize token))

shiftMetaToken! = (stack, token) ->
  stack.push 

shiftStartToken! = (stack, token) ->
  stack.push []

start? = \token ->
  token in startTokens

tokenize = \str ->
  tokenRegex =
    /[\s,]*(~@|[\[\]{}()'`~^@]|"(?:\\.|[^\\"])*"|;.*|[^\s\[\]{}('"`,;)]*)/g
  tokens = []
  while available? (token = tokenRegex.exec(str)[1])
    continue if comment? token
    tokens.push token
  tokens

listStart      = '('
listEnd        = ')'
vectorStart    = '['
vectorEnd      = ']'
hashmapStart   = '{'
hashmapEnd     = '}'
commentStart   = ';'
deref          = '@'
quote          = '\'' 
quasiquote     = '`'
unquote        = '~'
spliceUnquote  = '~@'
metadataMarker = '^'

startTokens = [listStart, vectorStart, hashmapStart]
endTokens   = [listEnd, vectorEnd, hashmapEnd]
metaTokens  = [deref, quote, quasiquote, unquote, spliceUnquote]

metaSymbols =
  '@'  : DEREF
  '`'  : QUASIQUOTE
  '\'' : QUOTE
  '~@' : SPLICE-UNQUOTE
  '~'  : UNQUOTE

seqTypeConstructors =
  ')' : createMalList
  ']' : createMalVector
  '}' : createMalHash

module.exports = read
